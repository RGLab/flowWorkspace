#' @include filterObject-Methods.R
NULL


#' Create a GatingSet and add/remove the flowCore gate(or population) to/from a GatingHierarchy/GatingSet.
#' 
#' \code{GatingSet} method creates a gatingset from a flowSet with the ungated data as the root node.
#' \code{add} method add the flowCore gate to a GatingHierarchy/GatingSet.
#' \code{setGate} method update the gate of one population node in GatingHierarchy/GatingSet.
#' \code{Rm} method Remove the population node from a GatingHierarchy/GatingSet. 
#' They are equivalent to the \code{workFlow},\code{add} and \code{Rm} methods in \code{flowCore} package. 
#' \code{recompute} method does the actual gating after the gate is added,i.e. calculating the event indices according to the gate definition.   
#' @param wf A \code{GatingHierrarchy} or \code{GatingSet}
#' @param envir A \code{GatingHierrarchy} or \code{GatingSet}
#' @param x A \code{GatingSet}
#' @param y a node index within a \code{GatingSet}. It is the root node if unspecified
#' @param action A \code{filter} or a list of \code{filter}s to be added to the  \code{GatingHierarchy} or \code{GatingSet}.
#' @param names  a \code{character} vector of length four,which specifies the population names resulted by adding a \code{quadGate}.
#' The order of the names is clock-wise starting from the top left quadrant population.
#' @param ... some other arguments to specify how the gates are added to the gating tree.
#' \itemize{
#'       \item parent: a \code{character} scalar to specify the parent node name where the new gate to be added to, by default it is NULL,which indicates the root node
#'       \item name: a \code{character} scalar to specify the node name of population that is generated by the gate to be added.
#'       The default value is NULL,then the name will be extracted from the filterId of the gate to be added 
#'       \item negated: a \code{logical} scalar to specify whether the gate is negated,which means the the population outside of the gate will be kept as the result population.
#'       It is FALSE by default. 
#'  }
#' @param symbol A \code{character} identifies the population node in a \code{GatingHierrarchy} or \code{GatingSet} to remove
#' @param subSymbol Not used.
#' @return 
#'   \code{GatingSet} method returns a \code{GatingSet} object with just root node.  
#'   \code{add} method returns a population node ID (or four population node IDs when adding a \code{quadGate}) that uniquely identify the population node within a  \code{GatingHierarchy}.
#' @seealso \code{\link{GatingSet-class}}
#' @examples
#' \dontrun{
#'     data(GvHD)
#' #select raw flow data
#'     fs<-GvHD[1:3]
#'     
#' #transform the raw data
#'     tf <- transformList(colnames(fs[[1]])[3:6], asinh, transformationId="asinh")
#'     fs_trans<-transform(fs,tf)
#'     
#' #add transformed data to a gatingset
#'     gs <- GatingSet(fs_trans)
#'     gs
#'     getNodes(gs[[1]]) #only contains root node
#'     
#' #add one gate
#'     rg <- rectangleGate("FSC-H"=c(200,400), "SSC-H"=c(250, 400),
#'         filterId="rectangle")
#'     
#'     nodeID<-add(gs, rg)#it is added to root node by default if parent is not specified
#'     nodeID
#'     getNodes(gs[[1]]) #the second population is named after filterId of the gate 
#'     
#' #add a quadGate
#'     qg <- quadGate("FL1-H"=2, "FL2-H"=4)
#'     nodeIDs<-add(gs,qg,parent="rectangle")
#'     nodeIDs #quadGate produces four population nodes
#'     getNodes(gs[[1]]) #population names are named after dimensions of gate if not specified
#'     
#' #add a boolean Gate
#'     bg<-booleanFilter(`CD15 FITC-CD45 PE+`|`CD15 FITC+CD45 PE-`)
#'     bg
#'     nodeID2<-add(gs,bg,parent="rectangle")
#'     nodeID2
#'     getNodes(gs[[1]])
#' #do the actual gating
#'     recompute(gs)
#'     
#' #plot one gate for one sample
#'     plotGate(gs[[1]],"rectangle")
#'     plotGate(gs[[1]],nodeIDs) #may be smoothed automatically if there are not enough events after gating
#'     
#' #plot gates across samples using lattice plot
#'     plotGate(gs,nodeID)
#' #plot all gates for one sample
#'     plotGate(gs[[1]])#boolean gate is skipped by default 
#'     plotGate(gs[[1]],bool=TRUE)
#'     
#' #plot the gating hierarchy
#'     require(Rgraphviz)
#'     plot(gs[[1]])
#' #remove one node causing the removal of all the descendants 
#'     Rm('rectangle', gs)
#'     getNodes(gs[[1]])
#'  }
#' 
#' @aliases 
#' add
#' add,GatingSet,list-method
#' add,GatingSet,filterList-method
#' add,GatingSet,filter-method
#' add,GatingSetList,list-method
#' add,GatingSetList,filterList-method
#' add,GatingSetList,filter-method
#' add,GatingHierarchy,quadGate-method
#' add,GatingHierarchy,filter-method
#' setGate
#' setGate,GatingSet,ANY,list-method
#' setGate,GatingSet,ANY,filterList-method
#' setGate,GatingHierarchy,numeric,filter-method
#' setGate,GatingHierarchy,character,filter-method
#' Rm
#' Rm,character,GatingSet,character-method
#' Rm,character,GatingHierarchy,character-method
#' Rm,character,GatingSetList,character-method
#' recompute
#' recompute,GatingSet-method
#' recompute,GatingSetList-method 
#' @export 
#' @importFrom flowCore add
setMethod("add",
		signature=c(wf="GatingSet", "list"),
		definition=function(wf, action, ...)
		{
			
			flist<-filterList(action)
			add(wf,flist,...)
			
		})
setMethod("add",
    signature=c(wf="GatingSetList", "list"),
    definition=function(wf, action, ...)
    {
      
      selectMethod("add",signature = c(wf="GatingSet", action="list"))(wf, action, ...)
      
    })    
    
        
    
#' @importClassesFrom flowCore filterList ellipsoidGate intersectFilter polygonGate rectangleGate
#' @importFrom flowCore filterList
setMethod("add",
		signature=c("GatingSet", "filterList"),
		definition=function(wf, action, ...)
		{
			samples<-sampleNames(wf)
			
			if(!setequal(names(action),samples))
				stop("names of filterList do not match with the sample names in the gating set!")			
			
			nodeIDs<-lapply(samples,function(sample){
								curFilter<-action[[sample]]
								gh<-wf[[sample]]
#								browser()
								add(wf=gh,action=curFilter,...)
							})
					
			nodeID<-nodeIDs[[1]]
		
		if(!all(sapply(nodeIDs[-1],function(x)identical(x,nodeID))))
			stop("nodeID are not identical across samples!")
		
		nodeID
			
		})
setMethod("add",
        signature=c("GatingSetList", "filterList"),
        definition=function(wf, action, ...)
        {
          selectMethod("add",signature = c(wf="GatingSet", action="filterList"))(wf, action, ...)
        })
setMethod("add",
		signature=c("GatingSet", "filter"),
		definition=function(wf, action, ...)
		{
			
			message("replicating filter '",identifier(action),"' across samples!")
			
			actions<-sapply(sampleNames(wf),function(x)return(action))
			add(wf,actions,...)
			
		})
setMethod("add",
    signature=c("GatingSetList", "filter"),
    definition=function(wf, action, ...)
    {
      
      selectMethod("add",signature = c(wf="GatingSet", action="filter"))(wf, action, ...)
      
    })

.addGate<-function(gh,filterObject,parent=NULL, name=NULL,negated=FALSE){
#  browser()
	if(is.null(name))
		name<-filterObject$filterId
    #replace the slash with colon 
    #since forward slash is reserved for gating path
  if(grepl("/",name)){
    old_name <- name
    name <- gsub("/",":",name)
    warning(old_name, " is replaced with ", name)
  }
    
#	browser()
	##get node ID
	
	if(is.null(parent))
		pid<-1
	else
	{
		if(is.numeric(parent))
			pid<-parent
		else
			pid<-.getNodeInd(gh,parent)
	}
	filterObject$negated<-negated
#	browser()	
	nodeID<-.Call("R_addGate",gh@pointer,getSample(gh),filterObject,as.integer(pid-1),name)
	nodeID+1
}


setMethod("add",
		signature=c("GatingHierarchy", "filter"),
		definition=function(wf, action,... )
		{
			
			.addGate(wf,filterObject(action),...)
		})


setMethod("add",
		signature=c("GatingHierarchy", "quadGate"),
		definition=function(wf, action,names=NULL,... )
		{
			
			#convert to four recgates			
			params<-parameters(action)
			pd<-pData(parameters(getData(wf)))
			desc<-sapply(params,function(x)flowWorkspace:::.getChannelMarker(pd,x)$des)
			
			v <- action@boundary[params[1]]
			h <- action@boundary[params[2]]
			mat <- matrix(c(-Inf, v, h, Inf
							, v, Inf, h, Inf
							, v, Inf, -Inf, h
							, -Inf, v, -Inf,h
							)
						, byrow=TRUE
						, ncol=4)              
			#clock-wise from top left quadrant
			if(is.null(names))
				names <- matrix(c(sprintf("%s-%s+", desc[1], desc[2]),
									sprintf("%s+%s+", desc[1], desc[2]),
									sprintf("%s+%s-", desc[1], desc[2]),
									sprintf("%s-%s-", desc[1], desc[2])
									),
								ncol=2)
			if(length(unique(names))!=4)
				stop("names have to be four unique strings!")
			unlist(lapply(1:4,function(i){
#								browser()
							rg <- rectangleGate(.gate=matrix(mat[i,], ncol=2,
											dimnames=list(c("min", "max"), params))
											,filterId=names[i])
							add(wf,rg,...)
						})
					)
			
			
			
		})
##TODO:Either to create a speical logicalGate derived from "filter"
## that just contains the logical vector as indices generated by other algrorithm 
## like flowClust..
## Or we could try to use filterResult and filterResultList from flowCore
## to save the efforts of adding new filter type, but the extra contructor is necessary to 
## convert logical vector to filterResult.
#setMethod("add",
#		signature=c("GatingHierarchy", "logicalGate"),
#		definition=function(wf, action, name,...)
#		{
#			
#			
##			browser()
#			if(missing(name))
#				stop("population name is required!")
#			if(length(action)!=nrow(getData(wf)))
#				stop("the length of logical vector is different from events number in: ",getSample(wf))
#			
#			
#			filterObject<-list(type=as.integer(6)
#								,indices=action
#								)	
#			
#			.addGate(wf,filterObject,...)
#		})

#' @importFrom flowCore Rm
setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingSet",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
			invisible(lapply(envir,function(gh){
#								browser()
								Rm(symbol,gh,subSymbol,...)
							}))
		})
setMethod("Rm",
    signature=c(symbol="character",
        envir="GatingSetList",
        subSymbol="character"),
    definition=function(symbol, envir, subSymbol, ...)
    {
      selectMethod("Rm"
          ,signature = c(symbol="character", envir="GatingSet", subSymbol="character"))(symbol, envir, subSymbol, ...)
    })
    

setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingHierarchy",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
#			browser()
            
            nid<-.getNodeInd(envir,symbol)
			##remove all children nodes as well
			childrenNodeIds <- getChildren(envir,nid)
            #use path instead of unqiue name since the prefix of unique name
            #will change during deletion
            childrenPaths <- getNodes(envir, showHidden = TRUE, isPath = TRUE)[childrenNodeIds]
            
#            #strip the first slash
#            childrenPaths <- sapply(childrenPaths,function(thisPath)substr(thisPath,2,nchar(thisPath)),USE.NAMES=F)
			lapply(childrenPaths,function(child)Rm(child,envir))
			
            
            
			.Call("R_removeNode",envir@pointer,getSample(envir),nid-1)
		})

