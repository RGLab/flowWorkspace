# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

gen_uid <- function() {
    .Call(`_flowWorkspace_gen_uid`)
}

#' construct the biexpTrans c++ object on the fly
#'
#' It returns the spline coefficients vectors to R.
#'
#' It is used to extract the spline coefficient vectors from the calibration table
#' which is computed by biexpTrans class and then return to R for constructing flowJo transformation function within R.
#' Mainly used for openCyto autoGating process where no xml workspace is needed to create flowJo transformation.
#' @noRd
.getSplineCoefs <- function(channelRange = 4096L, maxValue = 262144, pos = 4.5, neg = 0, widthBasis = -10, inverse = FALSE) {
    .Call(`_flowWorkspace_getSplineCoefs`, channelRange, maxValue, pos, neg, widthBasis, inverse)
}

#' store the transformation functions created from R into GatingSet
#'
#' @param gsPtr external pointer that points to the C data structure of GatingSet
#' @param transformList a transformList that constains a list of transformation functions.
#'         Each of these functions carries the attributes to be used to convert to c++ transformation
#' @noRd
.addTrans <- function(gsPtr, transformList) {
    invisible(.Call(`_flowWorkspace_addTrans`, gsPtr, transformList))
}

#' Update the channel information of a GatingSet (c++ part)
#' 
#' It updates the channels stored in gates,compensations and transformations
#' based on given mapping between the old and new channel names.
#' 
#' @param gs a GatingSet
#' @param sampleNames the sample names specifies samples to be operated on
#' @param map \code{data.frame} contains the mapping from old to new channel names
#'                             Note: Make sure to remove the '<' or '>' characters from 'old` name because the API tries 
#'                                   to only look at the raw channel name so that the gates with both prefixed and non-prefixed names could be updated. 
#'                                   
#' @examples 
#' \dontrun{
#'  updateChannels(gs, map = data.frame(old = c("Qdot 655-A")  ##this will update both "Qdot 655-A" and "<Qdot 655-A>"
#'                                          , new = c("<QDot 655-A>")
#'                                          )
#'                        , nodes = "14-")  
#'}
#' @noRd
.updateChannels <- function(gs, map) {
    invisible(.Call(`_flowWorkspace_updateChannels`, gs, map))
}

flush_idx <- function(gs, sn, unload_cache) {
    invisible(.Call(`_flowWorkspace_flush_idx`, gs, sn, unload_cache))
}

get_idx_uri <- function(gs, sn) {
    .Call(`_flowWorkspace_get_idx_uri`, gs, sn)
}

.cpp_plotGh <- function(gs, sampleName, output) {
    invisible(.Call(`_flowWorkspace_plotGh`, gs, sampleName, output))
}

.cpp_getNodes <- function(gs, sampleName, order, fullPath, showHidden) {
    .Call(`_flowWorkspace_getNodes`, gs, sampleName, order, fullPath, showHidden)
}

getNodePath <- function(gs, sampleName, id) {
    .Call(`_flowWorkspace_getNodePath`, gs, sampleName, id)
}

.cpp_getNodeID <- function(gs, sampleName, gatePath) {
    .Call(`_flowWorkspace_getNodeID`, gs, sampleName, gatePath)
}

.cpp_getParent <- function(gs, sampleName, gatePath) {
    .Call(`_flowWorkspace_getParent`, gs, sampleName, gatePath)
}

.cpp_getChildren <- function(gs, sampleName, gatePath, showHidden) {
    .Call(`_flowWorkspace_getChildren`, gs, sampleName, gatePath, showHidden)
}

.cpp_getPopStats <- function(gs, sampleName, gatePath) {
    .Call(`_flowWorkspace_getPopStats`, gs, sampleName, gatePath)
}

gh_remove_stats <- function(gs, sampleName, nodes, stats) {
    invisible(.Call(`_flowWorkspace_gh_remove_stats`, gs, sampleName, nodes, stats))
}

gh_add_stats <- function(gs, sampleName, nodes, stats) {
    invisible(.Call(`_flowWorkspace_gh_add_stats`, gs, sampleName, nodes, stats))
}

gh_ls_stats <- function(gs, sampleName) {
    .Call(`_flowWorkspace_gh_ls_stats`, gs, sampleName)
}

gh_compute_stats <- function(gs, sampleName, node) {
    invisible(.Call(`_flowWorkspace_gh_compute_stats`, gs, sampleName, node))
}

gh_ls_pop_stats <- function(gs, sampleName, node) {
    .Call(`_flowWorkspace_gh_ls_pop_stats`, gs, sampleName, node)
}

.cpp_getCompensation <- function(gs, sampleName) {
    .Call(`_flowWorkspace_getCompensation`, gs, sampleName)
}

set_transformations <- function(gs, sampleName, translist) {
    invisible(.Call(`_flowWorkspace_set_transformations`, gs, sampleName, translist))
}

.cpp_getTransformations <- function(gs, sampleName, inverse) {
    .Call(`_flowWorkspace_getTransformations`, gs, sampleName, inverse)
}

.cpp_getGate <- function(gs, sampleName, gatePath) {
    .Call(`_flowWorkspace_getGate`, gs, sampleName, gatePath)
}

.cpp_getIndices <- function(gs, sampleName, gatePath) {
    .Call(`_flowWorkspace_getIndices`, gs, sampleName, gatePath)
}

.cpp_setIndices <- function(gs, sampleName, u, ind) {
    invisible(.Call(`_flowWorkspace_setIndices`, gs, sampleName, u, ind))
}

.cpp_getGateFlag <- function(gs, sampleName, gatePath) {
    .Call(`_flowWorkspace_getGateFlag`, gs, sampleName, gatePath)
}

.cpp_getNegateFlag <- function(gs, sampleName, gatePath) {
    .Call(`_flowWorkspace_getNegateFlag`, gs, sampleName, gatePath)
}

.cpp_getHiddenFlag <- function(gs, sampleName, gatePath) {
    .Call(`_flowWorkspace_getHiddenFlag`, gs, sampleName, gatePath)
}

.cpp_addGate <- function(gs, sampleName, filter, gatePath, popName) {
    .Call(`_flowWorkspace_addGate`, gs, sampleName, filter, gatePath, popName)
}

.cpp_boolGating <- function(gs, sampleName, filter, nodeID) {
    invisible(.Call(`_flowWorkspace_boolGating`, gs, sampleName, filter, nodeID))
}

set_quadgate <- function(gs, sampleName, gatePath, inter) {
    invisible(.Call(`_flowWorkspace_set_quadgate`, gs, sampleName, gatePath, inter))
}

.cpp_setGate <- function(gs, sampleName, gatePath, filter) {
    invisible(.Call(`_flowWorkspace_setGate`, gs, sampleName, gatePath, filter))
}

.cpp_removeNode <- function(gs, sampleName, gatePath, recursive = FALSE) {
    invisible(.Call(`_flowWorkspace_removeNode`, gs, sampleName, gatePath, recursive))
}

#' move a node within the gating tree
#'
#' This is light-weight since it only update the edge in graph and requires user to
#' invoke recompute to update gating
#'
#' @param gsPtr external pointer that points to the C data structure of GatingSet
#' @param sampleName sample name
#' @param node node name
#' @noRd
.moveNode <- function(gsPtr, sampleName, node, parent) {
    invisible(.Call(`_flowWorkspace_moveNode`, gsPtr, sampleName, node, parent))
}

.cpp_setNodeName <- function(gs, sampleName, gatePath, newNodeName) {
    invisible(.Call(`_flowWorkspace_setNodeName`, gs, sampleName, gatePath, newNodeName))
}

.cpp_setNodeFlag <- function(gs, sampleName, gatePath, hidden) {
    invisible(.Call(`_flowWorkspace_setNodeFlag`, gs, sampleName, gatePath, hidden))
}

convert_idx_to_ondisk <- function(gsPtr) {
    invisible(.Call(`_flowWorkspace_convert_idx_to_ondisk`, gsPtr))
}

get_ondisk_idx_flag <- function() {
    .Call(`_flowWorkspace_get_ondisk_idx_flag`)
}

set_ondisk_idx_flag <- function(val) {
    invisible(.Call(`_flowWorkspace_set_ondisk_idx_flag`, val))
}

gs_transform_data <- function(gsPtr) {
    invisible(.Call(`_flowWorkspace_gs_transform_data`, gsPtr))
}

cpp_gating <- function(gsPtr, nodes, alwaysLoadData, verbose, leafbool) {
    invisible(.Call(`_flowWorkspace_cpp_gating`, gsPtr, nodes, alwaysLoadData, verbose, leafbool))
}

subset_gs_by_sample <- function(gsPtr, samples) {
    .Call(`_flowWorkspace_subset_gs_by_sample`, gsPtr, samples)
}

get_cytoset <- function(gsPtr) {
    .Call(`_flowWorkspace_get_cytoset`, gsPtr)
}

get_cytoset_from_node <- function(gsPtr, node) {
    .Call(`_flowWorkspace_get_cytoset_from_node`, gsPtr, node)
}

set_cytoset <- function(gsPtr, cs) {
    invisible(.Call(`_flowWorkspace_set_cytoset`, gsPtr, cs))
}

.cpp_getSamples <- function(gsPtr) {
    .Call(`_flowWorkspace_get_sample_uids`, gsPtr)
}

.cpp_NewGatingSet <- function(gsPtr, src_sample_uid, cs, execute, comp_source) {
    .Call(`_flowWorkspace_NewGatingSet`, gsPtr, src_sample_uid, cs, execute, comp_source)
}

get_gatingset_id <- function(gsPtr) {
    .Call(`_flowWorkspace_get_gatingset_id`, gsPtr)
}

set_gatingset_id <- function(gsPtr, id) {
    invisible(.Call(`_flowWorkspace_set_gatingset_id`, gsPtr, id))
}

.cpp_saveGatingSet <- function(gs, path, backend_opt, ctx) {
    invisible(.Call(`_flowWorkspace_save_gatingset`, gs, path, backend_opt, ctx))
}

.cpp_loadGatingSet <- function(path, readonly, select_samples, verbose, ctx, load_format) {
    .Call(`_flowWorkspace_load_gatingset`, path, readonly, select_samples, verbose, ctx, load_format)
}

load_legacy_gs <- function(pbfile, cs) {
    .Call(`_flowWorkspace_load_legacy_gs`, pbfile, cs)
}

.cpp_CloneGatingSet <- function(gs, h5_dir, is_copy_data) {
    .Call(`_flowWorkspace_CloneGatingSet`, gs, h5_dir, is_copy_data)
}

.cpp_combineGatingSet <- function(gsList, sampleList) {
    .Call(`_flowWorkspace_combineGatingSet`, gsList, sampleList)
}

.cpp_setSample <- function(gs, oldName, newName) {
    invisible(.Call(`_flowWorkspace_set_sample_uid`, gs, oldName, newName))
}

#' check whether cytolib is build with tiledb support
#' @return TRUE or FALSE
#' @export
is_tiledb_support <- function() {
    .Call(`_flowWorkspace_is_tiledb_support`)
}

.cpp_getLogLevel <- function() {
    .Call(`_flowWorkspace_getLogLevel`)
}

.cpp_setLogLevel <- function(loglevel) {
    invisible(.Call(`_flowWorkspace_setLogLevel`, loglevel))
}

.cpp_togleErrorFlag <- function() {
    invisible(.Call(`_flowWorkspace_toggleErrorFlag`))
}

del_rownames <- function(fr) {
    invisible(.Call(`_flowWorkspace_del_rownames`, fr))
}

set_rownames <- function(fr, val) {
    invisible(.Call(`_flowWorkspace_set_rownames`, fr, val))
}

get_rownames <- function(fr) {
    .Call(`_flowWorkspace_get_rownames`, fr)
}

backend_type <- function(fr) {
    .Call(`_flowWorkspace_backend_type`, fr)
}

cf_is_indexed <- function(fr) {
    .Call(`_flowWorkspace_cf_is_indexed`, fr)
}

.cf_scale_time_channel <- function(fr) {
    invisible(.Call(`_flowWorkspace_cf_scale_time_channel`, fr))
}

cf_set_readonly <- function(fr, flag) {
    invisible(.Call(`_flowWorkspace_cf_set_readonly`, fr, flag))
}

.cf_flush_meta <- function(fr) {
    invisible(.Call(`_flowWorkspace_cf_flush_meta`, fr))
}

.cf_load_meta <- function(fr) {
    invisible(.Call(`_flowWorkspace_cf_load_meta`, fr))
}

get_uri <- function(fr) {
    .Call(`_flowWorkspace_get_uri`, fr)
}

realize_view_cytoframe <- function(fr, filename) {
    .Call(`_flowWorkspace_realize_view_cytoframe`, fr, filename)
}

copy_view_cytoframe <- function(fr) {
    .Call(`_flowWorkspace_copy_view_cytoframe`, fr)
}

subset_cytoframe_by_rows <- function(fr, idx) {
    invisible(.Call(`_flowWorkspace_subset_cytoframe_by_rows`, fr, idx))
}

subset_cytoframe_by_cols <- function(fr, idx) {
    invisible(.Call(`_flowWorkspace_subset_cytoframe_by_cols`, fr, idx))
}

frm_compensate <- function(fr, spillover) {
    invisible(.Call(`_flowWorkspace_frm_compensate`, fr, spillover))
}

write_to_disk <- function(fr, filename, ish5, ctx) {
    invisible(.Call(`_flowWorkspace_write_to_disk`, fr, filename, ish5, ctx))
}

load_cf <- function(url, readonly, on_disk, ctx) {
    .Call(`_flowWorkspace_load_cf`, url, readonly, on_disk, ctx)
}

cf_to_memcf <- function(fr) {
    .Call(`_flowWorkspace_cf_to_memcf`, fr)
}

setMarker <- function(fr, channel, marker) {
    invisible(.Call(`_flowWorkspace_setMarker`, fr, channel, marker))
}

set_all_channels <- function(fr, new_names) {
    invisible(.Call(`_flowWorkspace_set_all_channels`, fr, new_names))
}

setChannel <- function(fr, old, new_name) {
    invisible(.Call(`_flowWorkspace_setChannel`, fr, old, new_name))
}

get_channels <- function(fr) {
    .Call(`_flowWorkspace_get_channels`, fr)
}

append_cols <- function(fr, new_colnames, new_cols_mat) {
    .Call(`_flowWorkspace_append_cols`, fr, new_colnames, new_cols_mat)
}

parseFCS <- function(filename, config, text_only = FALSE, format = "mem", uri = "") {
    .Call(`_flowWorkspace_parseFCS`, filename, config, text_only, format, uri)
}

cf_getData <- function(fr) {
    .Call(`_flowWorkspace_cf_getData`, fr)
}

cf_setData <- function(fr, data) {
    invisible(.Call(`_flowWorkspace_cf_setData`, fr, data))
}

cf_getKeyword <- function(fr, key) {
    .Call(`_flowWorkspace_cf_getKeyword`, fr, key)
}

cf_getKeywords <- function(fr) {
    .Call(`_flowWorkspace_cf_getKeywords`, fr)
}

setKeywords <- function(fr, keys) {
    invisible(.Call(`_flowWorkspace_setKeywords`, fr, keys))
}

getncol <- function(fr) {
    .Call(`_flowWorkspace_getncol`, fr)
}

getnrow <- function(fr) {
    .Call(`_flowWorkspace_getnrow`, fr)
}

setpdata <- function(fr, df) {
    invisible(.Call(`_flowWorkspace_setpdata`, fr, df))
}

getpdata <- function(fr) {
    .Call(`_flowWorkspace_getpdata`, fr)
}

#' @param comps a list of NumericMatrix
#' @param compensate_data Typically we set it to true to compensate the data as we set comp, Only when we convert the legacy gs, do we skipping this part.
cs_set_compensation <- function(cs, comps, compensate_data) {
    invisible(.Call(`_flowWorkspace_cs_set_compensation`, cs, comps, compensate_data))
}

set_cytoframe <- function(cs, sn, fr) {
    invisible(.Call(`_flowWorkspace_set_cytoframe`, cs, sn, fr))
}

add_cytoframe <- function(cs, sn, fr) {
    invisible(.Call(`_flowWorkspace_add_cytoframe`, cs, sn, fr))
}

new_cytoset <- function() {
    .Call(`_flowWorkspace_new_cytoset`)
}

fcs_to_cytoset <- function(sample_uid_vs_file_path, config, backend, backend_dir) {
    .Call(`_flowWorkspace_fcs_to_cytoset`, sample_uid_vs_file_path, config, backend, backend_dir)
}

get_colnames <- function(cs) {
    .Call(`_flowWorkspace_get_colnames`, cs)
}

realize_view_cytoset <- function(cs, path) {
    .Call(`_flowWorkspace_realize_view_cytoset`, cs, path)
}

copy_view_cytoset <- function(cs) {
    .Call(`_flowWorkspace_copy_view_cytoset`, cs)
}

subset_cytoset_by_rows <- function(cs, sn, idx) {
    invisible(.Call(`_flowWorkspace_subset_cytoset_by_rows`, cs, sn, idx))
}

subset_cytoset <- function(cs, i_obj, j_obj) {
    invisible(.Call(`_flowWorkspace_subset_cytoset`, cs, i_obj, j_obj))
}

get_cytoframe <- function(cs, i_obj, j_obj) {
    .Call(`_flowWorkspace_get_cytoframe`, cs, i_obj, j_obj)
}

set_pheno_data <- function(cs, value) {
    invisible(.Call(`_flowWorkspace_set_pheno_data`, cs, value))
}

get_pheno_data <- function(cs) {
    .Call(`_flowWorkspace_get_pheno_data`, cs)
}

#' grab all the descendant nodes for a given node
#'
#' This is a faster version of flowIncubator:::getDescendants
#'
#' @param gsPtr external pointer that points to the C data structure of GatingSet
#' @param sampleName sample name
#' @param node node name
#' @noRd
.getDescendants <- function(gsPtr, sampleName, node) {
    .Call(`_flowWorkspace_getDescendants`, gsPtr, sampleName, node)
}

#' grab vectors of pop counts and the parent counts along with their paths and FCS filenames
#'
#' This speeds up the process of getPopStats by putting the loop in c++ and avoiding copying while constructing vectors
#'
#' @param gsPtr external pointer that points to the C data structure of GatingSet
#' @param freq logical flag indicating whether counts should be converted to frequencies
#' @param sampleNames sample names vector
#' @param subpopulation population vector that specify the subset of pops to query
#' @param flowJo logical flag to specify whether flowCore or flowJo counts to return
#' @param isFullPath logical flag to specify whether return the full path or partial path of populations
#' @importFrom RcppParallel RcppParallelLibs
#' @noRd
.getPopCounts <- function(gsPtr, freq, subpopulation, flowJo, isFullPath) {
    .Call(`_flowWorkspace_getPopCounts`, gsPtr, freq, subpopulation, flowJo, isFullPath)
}

.cpp_getSingleCellExpressionByGate <- function(gs, sampleName, markers_pops, data, markers, threshold) {
    .Call(`_flowWorkspace_getSingleCellExpressionByGate`, gs, sampleName, markers_pops, data, markers, threshold)
}

.cpp_getSingleCellExpression <- function(gs, sampleName, pops, data, markers, threshold) {
    .Call(`_flowWorkspace_getSingleCellExpression`, gs, sampleName, pops, data, markers, threshold)
}

h5_set_error_handler <- function() {
    invisible(.Call(`_flowWorkspace_h5_set_error_handler`))
}

#' set the event counts for a given node
#'
#'
#' @param gsPtr external pointer that points to the C data structure of GatingSet
#' @param sampleName sample name
#' @param node node name
#' @param count the event count to be stored
#' @noRd
.set.count.xml <- function(gsPtr, sampleName, node, count) {
    invisible(.Call(`_flowWorkspace_setCounts`, gsPtr, sampleName, node, count))
}

