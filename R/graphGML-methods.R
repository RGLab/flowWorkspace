#' get nodes from {graphGML} object
#'
#' @param x \code{graphGML}
#' @param y \code{character} node index. When \code{missing}, return all the nodes
#' @param order \code{character} specifying the order of nodes. options are "default", "bfs", "dfs", "tsort"
#' @param only.names \code{logical} specifiying whether user wants to get the entire \code{nodeData} or just the name of the population node
#' @return It returns the node names and population names by default. Or return the entire nodeData associated with each node.   
#' @export
#' @examples 
#' \dontrun{
#' xmlfile <- system.file("extdata/cytotrol_tcell_cytobank.xml", package = "flowWorkspace")
#' g <- read.gatingML.cytobank(xmlfile)
#' getNodes(g)
#' getNodes(gt, only.names = FALSE)
#' } 
setMethod("getNodes", signature = c("graphGML"),
          definition = function(x, y
                                  , order = c("default", "bfs", "dfs", "tsort")
                                  , only.names = TRUE) {
  
  if (missing(y)){
    res <- nodeData(x)
    order <- match.arg(order)
    if(order != "default"){
      nodeIds <- eval(substitute(f1(x),list(f1=as.symbol(order))))
      if(order == "dfs")
        nodeIds <- nodeIds$discovered
      res <- res[nodeIds]
    }
  }else
  {
    res <- nodeData(x, y)
    
  }
  if(only.names){
    res <- sapply(res,`[[`,"popName")
  }
  if(length(res) == 1 && class(res) == "list")
      res <- res[[1]]
   res
})

#' get full path of the parent
#' @inheritParams getNodes
getPath <- function(x, y){
  #get full path
  nodeIds <- y
  thisNodeID <- y
  while(length(thisNodeID) > 0){
    thisNodeID <- getParent(x, thisNodeID)
    nodeIds <- c(thisNodeID,nodeIds)
  }
  
  pops <- lapply(nodeIds, function(i)nodeData(x,i)[[1]][["popName"]])
  path <- paste(pops, collapse = "/")
  paste0("/", path)
}

#' get children nodes
#'
#' @param obj \code{graphGML}
#' @param y \code{character} parent node path  
#' @export 
#' @examples 
#' \dontrun{
#' xmlfile <- system.file("extdata/cytotrol_tcell_cytobank.xml", package = "flowWorkspace")
#' g <- read.gatingML.cytobank(xmlfile)
#' getChildren(g, "GateSet_694130")
#' getParent(g, "GateSet_694130") 
#' }
#' @importClassesFrom methods character ANY data.frame environment list logical matrix missing numeric oldClass
setMethod("getChildren", signature = c("graphGML", "character"),
          definition = function(obj, y) {
  edges(obj, y)[[1]]
})

#' get parent nodes
#' 
#' @param obj \code{graphGML}
#' @param y \code{character} child node path
#' 
#' @export
setMethod("getParent", signature = c("graphGML", "character"),
          definition = function(obj, y) {

   inEdges(y, obj)[[1]]
  
})

#' get gate from the node
#' 
#' @param obj \code{graphGML}
#' @param y \code{character} node path
#' @export 
setMethod("getGate", signature = c("graphGML", "character"),
          definition = function(obj, y) {

          nodeData(obj, y)[["gateInfo"]]
})


#' show method for graphGML
#' 
#' show method for graphGML
#' 
#' @param object \code{graphGML}
#' @export 
#' @importFrom methods show
setMethod("show", signature = c("graphGML"),
          definition = function(object) {
  cat("--- Gating hieararchy parsed from GatingML: ")
  
  cat("\n")
  cat("\twith ", length(object@nodes), " populations defined\n")
})


#' plot the population tree stored in graphGML.
#' 
#' The node with dotted order represents the population that has tailored gates (sample-specific gates) defined.
#'  
#' @param x a graphNEL generated by constructTree function
#' @param y not used
#' @param label specifies what to be dispaled as node label. Can be either 'popName' (population name parsed from GateSets) or 'gateName'(the name of the actual gate associated with each node)
#' @export
#' @importFrom graph nodeData nodes<- nodeRenderInfo<-
#' @importFrom Rgraphviz renderGraph layoutGraph
#' @examples 
#' \dontrun{
#' xmlfile <- system.file("extdata/cytotrol_tcell_cytobank.xml", package = "flowWorkspace")
#' g <- read.gatingML.cytobank(xmlfile)
#' plot(g)
#'  
#' }

setMethod("plot", signature = c(x = "graphGML", y = "missing"), definition = function(x, y = "missing", label = c("popName", "gateName")){
  label <- match.arg(label, c("popName", "gateName"))
  if(label == "popName")
    nodeLabel  <- sapply(nodeData(x), `[[`, "popName")
  else
    nodeLabel  <- sapply(nodeData(x), function(i)i[["gateInfo"]][["gateName"]])
  
  
  #annotate the node with tailor gate info
  nTailoredGate <- sapply(nodeData(x), function(i)length(i[["gateInfo"]][["tailored_gate"]]))
  
  nAttrs <- list()
  
  nAttrs$label <- nodeLabel
  
  nAttrs$lty <- sapply(nTailoredGate
                       ,function(i)
                       {
                         ifelse(i>0,"dotted","solid")
                       })
  
  nodeRenderInfo(x) <- nAttrs
  lay <- layoutGraph(x
                     ,attrs=list(graph=list(rankdir="LR",page=c(8.5,11))
                                 ,node=list(fixedsize=FALSE
                                            ,fontsize = 12
                                            ,shape="ellipse"
                                 )
                     )
  )
  renderGraph(lay)
  
})

#' Apply the gatingML graph to a GatingSet
#' 
#' It applies the gates to the GatingSet based on the population tree described in graphGML.
#' 
#' @param x graphGML
#' @param y GatingSet
#' @param ... other arguments
#' @return 
#' Nothing. As the side effect, gates generated by gating methods are saved in \code{GatingSet}. 
#' @export
#' @rdname gating-methods
setGeneric("gating", function(x, y, ...) standardGeneric("gating"))

#' @aliases 
#' gating,graphGML,GatingSet-method
#' @rdname gating-methods
setMethod("gating", signature = c("graphGML", "GatingSet"), function(x, y, ...){
  gating.graphGML(x, y, ...)
})

#' @importFrom RBGL tsort
gating.graphGML <- function(gt, gs, ...) {
  
  trans <- getTransformations(gt)
  
  gt_nodes <- tsort(gt)
  for (nodeID in gt_nodes) {
    
    # get parent node to gate
    gt_node <- getNodes(gt, nodeID, only.names = F)
    popName <- gt_node[["popName"]]
    
    
    parentID <- getParent(gt, nodeID)
    
    if(length(parentID) == 0)
      parent <- "root"
    else{
      parent <- getPath(gt, parentID)
    }
      
    
    gs_nodes <- basename(getChildren(gs[[1]], parent))
    
    if (length(gs_nodes) == 0)
      isGated <- FALSE
    else
      isGated <- any(popName %in% gs_nodes)
    
    #TODO: rename the node name with path in order to match against gs    
#     parentInd <- match(parent, getNodes(gs[[1]], showHidden = TRUE))
#     if (is.na(parentInd)) 
#       stop("parent node '", parent, "' not gated yet!")
    if(isGated){
      message("Skip gating! Population '", paste(popName, collapse = ","), "' already exists.")
      next
    }
    message(popName)
    gateInfo <- gt_node[["gateInfo"]]
    this_gate <- gateInfo[["gate"]]
    
#     if(popName == "PD-1(Histo)")
#       browser()
    
    # transform bounds if applicable
    bound <- gateInfo[["bound"]]
    if(!is.null(trans))
    {
      for(rn in rownames(bound)){
        thisTrans <- trans[[rn]]
        if(!is.null(thisTrans))
          bound[rn, ] <- thisTrans[["transform"]](unlist(bound[rn, ]))
      }  
    }
    
      
    this_gate <- extend(this_gate,bound = bound)
    
    sn <- sampleNames(gs)
    this_gate <- sapply(sn, function(i)this_gate)
    
    #update gates that are tailored for specific samples
    tailor_gate <- gateInfo[["tailored_gate"]]
    tg_sn <- names(tailor_gate)
    tg_sn <- tg_sn[tg_sn %in% sn] #filter tailor gates in case sample set provided are not complete
    if(length(tg_sn) >0){
      this_tgs <- lapply(tailor_gate[tg_sn], extend,bound = bound)  
      this_gate[tg_sn] <- this_tgs
    }
    
    
    
    
    add(gs, this_gate, parent = parent, name = popName)
    
  } 
  recompute(gs)
}

#' Extract compensation from graphGML object.
#' @param x graphGML
#' @return compensation object or "FCS" when compensation comes from FCS keywords
#' @export
setMethod("getCompensationMatrices", signature = "graphGML", definition = function(x){
  x@graphData[["compensation"]]
  
})

#' Extract transformations from graphGML object.
#' @param x graphGML
#' @return transformerList object
#' @importFrom flowCore eval parameters colnames
#' @export
setMethod("getTransformations", signature = c(x = "graphGML"), function(x){
  trans <- x@graphData[["transformations"]]
  if(!is.null(trans)){
    chnls <- names(trans)
    trans <- sapply(trans, function(thisTrans){
      
      #convert from transform object to function since transform has empty function in .Data slot
      #which is not suitable for transformList constructor  
      trans.fun <- eval(thisTrans)
      trans.type <- class(thisTrans)
      if(extends(trans.type, "asinhtGml2")){
        inv.func <- asinh_Gml2(thisTrans@T, thisTrans@M, thisTrans@A, inverse = TRUE)
        
      }else
        stop("Don't know how to inverse transformation: ", trans.type)
      
      trans.obj <- flow_trans(trans.type, trans.fun, inv.func)
      
    }
    , USE.NAMES = FALSE, simplify = FALSE)
    
    trans <- transformerList(chnls, trans)
  }
  trans
})

#' compensate a GatingSet based on the compensation information stored in graphGML object
#' 
#' 
#' @param x GatingSet
#' @param spillover graphGML
#' @param ... unused.
#' @return compensated GatingSet
#' @importFrom flowCore compensate
#' @export
setMethod("compensate", signature = c("GatingSet", "graphGML"), function(x, spillover, ...){
  
  comp <- getCompensationMatrices(spillover)
  if(is(comp, "compensation")){
    prefix <- TRUE
    skip <- FALSE
  }else if(comp == "FCS"){
    prefix <- FALSE
    fs <- getData(x)
    fr <- fs[[1, use.exprs = FALSE]]
    #can't use spillover method directly because it will error out when none is found
    mat <- keyword(fr, c("spillover", "SPILL"))
    mat <- compact(mat)
    if(length(mat) == 0){
      skip <- TRUE
      warning("Compensation is skipped!Because gates refer to 'FCS' for compensation but no spillover is found in FCS.")
    }else{
      skip <- FALSE
      mat <- mat[[1]]  
      comp <- compensation(mat)
    }
  }
  if(skip)
    x
  else{
    
    if(prefix){
      
      comp_param <- colnames(comp@spillover)
      #strip prefix
      comp_param <- sapply(comp_param, function(i)sub("(^Comp_)(.*)", "\\2", i), USE.NAMES = FALSE)
      #match to chnls
      chnls <- colnames(x)
      ind <- match(comp_param, chnls)
      chnls[ind] <- paste0("Comp_", chnls[ind])
      colnames(x) <- chnls
    }
    compensate(x, comp)
  }
    
})
